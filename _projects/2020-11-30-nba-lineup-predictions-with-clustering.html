---
layout: post
title: "Predicting NBA lineup point differentials based on player-season clustering"
date: 2020-11-30
location: Franconia, New Hampshire, USA
math: true
link:
  - https://github.com/ajpkim/nba-lineup-predictions-with-player-clustering
  - github
---

<div id="outline-container-orgc2e8e2b" class="outline-2">
<h2 id="1.-Project-Description">1. Project Description</h2>
<div class="outline-text-2" id="text-1.-Project-Description">
<p>
In this project I gathered and clustered individual NBA player-seasons from 2000-2020 into 12 clusters using a gaussian mixture model with the goal of grouping together player-seasons with similar <i>playing style</i> (e.g. shot creation/selection/frequency), <i>efficiency</i> (e.g. true shooting percentage), and <i>overall impact</i> (e.g. box plus/minus). These clusters better represent the diverse functional roles that basketball players fill than the traditional 5 positions: point guard, shooting guard, small forward, power forward, and center. After identifying some interesting characteristics and league trends related to the clusters, I gathered NBA lineup data from 2000-2020 and attempted to predict lineup point-differentials per 100 possessions with a simple artificial neural network.
</p>

<p>
The inputs to the networks were lineup cluster profiles which were built by summing the player cluster labels across all players in a given lineup. The training targets were the observed lineup point-differentials per 100 possessions. Additionally, I attempted to predict lineup success with bpm-weighted cluster profiles that provide more information about the strengths and weaknesses of each lineup with respect to the clusters. The best performing network achieved a mean test error of around 5.6 points, a sizable error with respect to NBA lineup point differentials. All the data was scraped from the website <a href="https://www.basketball-reference.com/players/i/iversal01.html">basketball reference</a>.
</p>
</div>
</div>
<div id="outline-container-orgabd44be" class="outline-2">
<h2 id="Table-of-Contents">Table of Contents</h2>
<div class="outline-text-2" id="text-Table-of-Contents">
<ul class="org-ul">
<li><a href="#1.-Project-Description">1. Project Description</a></li>
<li><a href="#2.-NBA-context">2. NBA Context</a></li>
<li><a href="#3.-Building-the-player-dataset">3. Building the Player Dataset</a>
<ul class="org-ul">
<li><a href="#3.1.-scraping-player-season-stats-&-biographical-data">3.1. Scraping player-season stats &amp; biographical data</a></li>
<li><a href="#3.2.-cleaning-the-data">3.2. Cleaning the data</a></li>
<li><a href="#3.3.-transforming-the-data">3.3. Transforming the data</a></li>
<li><a href="#3.4.-principal-component-analysis-(PCA)">3.4. Principal component analysis (PCA)</a></li>
</ul></li>
<li><a href="#4.-Clustering">4. Clustering</a>
<ul class="org-ul">
<li><a href="#4.1.-clusters-overview">4.1. Clusters overview</a></li>
<li><a href="#4.2.-PCA-plots-to-visualize-cluster-spacing">4.2. PCA plots to visualize cluster spacing</a></li>
<li><a href="#4.3.-clusters-vs-traditional-positions">4.3. Clusters vs traditional positions</a></li>
<li><a href="#4.4.-finances-&-player-counts">4.4. Finances &amp; player counts</a></li>
</ul></li>
<li><a href="#5.-Lineup-analysis">5. Lineup Analysis</a>
<ul class="org-ul">
<li><a href="#5.1.-scraping-lineup-data">5.1. Scraping lineup data</a></li>
<li><a href="#5.2.-building-lineup-cluster-profiles">5.2. Building lineup cluster profiles</a></li>
<li><a href="#5.3.-lineup-correlations-&-salaries">5.3. Lineup correlations &amp; salaries</a></li>
<li><a href="#5.4.-predicting-lineup-point-differentials">5.4. Predicting lineup point differentials</a></li>
</ul></li>
<li><a href="#6.-Wrapping-Up">6. Wrapping Up</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5f620d5" class="outline-2">
<h2 id="2.-NBA-context">2. NBA Context</h2>
<div class="outline-text-2" id="text-2.-NBA-context">
<p>
The NBA today is a fast moving landscape of player archetypes, player movement, team playing styles, and team-building strategies. Even the rules are changing with great rapidity as replay has become more available and players exploit the current boundaries of the game to hunt down advantages with increased <a href="https://youtu.be/aZarLAPyj-c?t=15">focus and guile</a>. Bruising big men are out, three pointers are in, defensive switchability is at a premium, championship equity is common parlance, and twitter burner accounts are the cherry on top of the most entertaining sports league.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> <sup>, </sup><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>

<p>
Many NBA front offices today are active experimenters, or at least willing followers of the innovators, in roster construction and player development. Having embraced new concepts, metrics, and aesthetics, teams trot out funky lineups, exploring different avenues to find any edge - including improved draft lottery odds.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> The willingness to explore the structure of basketball and build new mental models for thinking about the game is bound to continue uncovering competitive insights along with plenty of dead-ends.
</p>

<p>
As fans, how we watch and understand the game has been tugged along by the current of the game. We have been force-fed shot chart maps highlighting what a healthy shot diet consists in and now we grimace watching our favorite team's young star indulge in taking difficult deep 2-pointers;<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> a habit of many stars of yesteryear. The previously niche lexicon of analytics has gradually wedged itself into a central role in our watching, understanding, and debating.
</p>

<p>
And yet at the core of things remain the traditional 5 positions, unchanged for decades, and continuing to passively frame our expectations, imagination, and understanding of basketball. Positions are the most common currency of description when discussing players and teams. Each position maps to a suite of functional roles and these boundaries help us to organize and chunk the game of basketball into manageable components when playing, coaching, evaluating, and watching. Positions are indeed necessary, but as with <i>everything</i> we should be aware of the role these concepts play in shaping our perspective on the very thing they purport to describe.
</p>

<p>
In the NBA today the best example of an over-discounted positional outlier is Ben Simmons. He is an elite defender, passer, and one-player transition engine, but he refuses to shoot from distance. His positive qualities make him an All-NBA player (i.e. roughly a top 15 player in the league). However, when his skills and weaknesses are combined in a single package, the sum elicits great confusion and his value is questioned. He falls far outside our established frameworks for understanding the game, and thus - to my mind - is underrated by many fans.
</p>

<p>
The influence of the positional hierarchy is far-reaching. For example, many who played basketball growing up are familiar with the lazy assignment of the smallest kid to point guard and the biggest kid to center. This pigeon-holing is common, and reveals a pervasive unthinking habit of mapping players to defined traditional roles solely based on height and stature. Real decision makers in the NBA must have sophisticated heuristics for understanding player roles and potential, but as fans it is time we to update our taxonomy of players to better reflect the playing style, efficiency, and value of players in the NBA today.
</p>
</div>
</div>

<div id="outline-container-org5304a22" class="outline-2">
<h2 id="3.-Building-the-player-dataset">3. Building the Player Dataset</h2>
<div class="outline-text-2" id="text-3.-Building-the-player-dataset">
<p>
The first set of tasks was gathering the statistical data, cleaning it, combining it with other useful data, and transforming it to so that the combined dataset is easier to analyze and use with machine learning algorithms.
</p>
</div>

<div id="outline-container-org0562c6e" class="outline-3">
<h3 id="3.1.-scraping-player-season-stats-&-biographical-data">3.1. Scraping player-season stats &amp; biographical data</h3>
<div class="outline-text-3" id="text-3.1.-scraping-player-season-stats-&-biographical-data">
<p>
I initially scraped data from <a href="https://nba.com/stats">nba.com/stats</a> but switched to <a href="https://www.basketball-reference.com/players/i/iversal01.html">basketball reference</a>. Basketball reference has all statistics I was hoping to make use of, as well as the convenient feature of using unique player ids throughout the site.<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup> These ids make it easy to verify and combine data from various areas on the site, such as player stats, player biographical information, and lineup data. I gathered four types of player statistics from the 1996-97 season through the 2019-20 season:
</p>

<ul class="org-ul">
<li><b>advanced</b>: e.g. box plus/minus, true shooting percentage, usage percentage</li>
<li><b>shooting</b>: e.g. percent of field goals taken from 0-3 feet away, percent of 3-pointers that were assisted</li>
<li><b>play-by-play</b>: e.g. percent of minutes spent at each traditional position, number of bad pass turnovers, total number of points generated by assists</li>
<li><b>per 100 possessions</b>: e.g. points/100 poss., free throws attempted/100 poss.</li>
</ul>

<p>
To scrape the data I used <code>selenium</code> to automate site navigation and expose the correct stat tables, <code>beautiful soup</code> to parse the html tables, and <code>pandas</code> to store the extracted data. The four stat types contained 88 distinct stat columns when combined on year and player ids to form a single player-season. To supplement these statistics I used the <code>sportsreference</code> api <sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup> to gather biographical data from basketball reference that included height, weight, salary, and nationality.
</p>

<details>

 <summary>
<i>Scraping code</i>
 </summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> time
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>

<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">from</span> bs4 <span class="org-keyword">import</span> BeautifulSoup
<span class="org-keyword">import</span> selenium
<span class="org-keyword">from</span> selenium <span class="org-keyword">import</span> webdriver
<span class="org-keyword">from</span> selenium.webdriver.common.action_chains <span class="org-keyword">import</span> ActionChains
<span class="org-keyword">from</span> selenium.webdriver.common.keys <span class="org-keyword">import</span> Keys


<span class="org-keyword">def</span> <span class="org-function-name">select_season</span>(browser, season):
    <span class="org-doc">"Navigate browser to the given season."</span>
    <span class="org-variable-name">url</span> = f<span class="org-string">'https://www.basketball-reference.com/leagues/NBA_{season}_per_poss.html'</span>
    browser.get(url)

<span class="org-keyword">def</span> <span class="org-function-name">select_stat_table</span>(browser, stat_table):
    <span class="org-doc">"Navigate browser to the given statistic table. Current season must be 1995-96 onward."</span>
    <span class="org-variable-name">stat_table_dict</span> = {<span class="org-string">'totals'</span>: 1,
                      <span class="org-string">'per_game'</span>: 2,
                      <span class="org-string">'per_minute'</span>: 3,
                      <span class="org-string">'per_poss'</span>: 4,
                      <span class="org-string">'advanced'</span>: 5,
                      <span class="org-string">'pbp'</span>: 6,
                      <span class="org-string">'shooting'</span>: 7,
                      <span class="org-string">'adj_shooting'</span>: 8}
    <span class="org-variable-name">n</span> = stat_table_dict[stat_table]
    <span class="org-variable-name">button_xpath</span> = f<span class="org-string">'/html/body/div[2]/div[5]/div[2]/div[{n}]/a'</span>
    browser.find_element_by_xpath(button_xpath).click()

<span class="org-keyword">def</span> <span class="org-function-name">read_stat_table</span>(soup):
    <span class="org-doc">"Parse the html table on the bs4 object's current page and return stats DataFrame."</span>
    <span class="org-variable-name">table</span> = soup.find(class_=<span class="org-string">"table_outer_container"</span>)
    <span class="org-variable-name">tbody</span> = table.find(<span class="org-string">'tbody'</span>)
    <span class="org-variable-name">tbody_tr</span> = tbody.find_all(<span class="org-string">'tr'</span>)
    <span class="org-variable-name">stat_cols</span>, <span class="org-variable-name">all_stats</span>, <span class="org-variable-name">all_ids</span> = [], [], []

    <span class="org-keyword">for</span> row <span class="org-keyword">in</span> tbody_tr:
        <span class="org-comment-delimiter"># </span><span class="org-comment">skip partial rows i.e. player entries with multiple teams</span>
        <span class="org-keyword">if</span> row[<span class="org-string">'class'</span>] != [<span class="org-string">"full_table"</span>]: <span class="org-keyword">continue</span>
        <span class="org-variable-name">cols</span> = row.find_all(<span class="org-string">'td'</span>)
        <span class="org-keyword">if</span> stat_cols == []:  <span class="org-comment-delimiter"># </span><span class="org-comment">extract stat names</span>
            <span class="org-variable-name">stat_cols</span> = [col.get(<span class="org-string">'data-stat'</span>) <span class="org-keyword">for</span> col <span class="org-keyword">in</span> cols]
        <span class="org-variable-name">player_stats</span> = [col.text <span class="org-keyword">for</span> col <span class="org-keyword">in</span> cols]  <span class="org-comment-delimiter"># </span><span class="org-comment">extract player stat values</span>
        all_stats.append(player_stats)
        <span class="org-variable-name">player_id</span> = cols[0].get(<span class="org-string">'data-append-csv'</span>)  <span class="org-comment-delimiter"># </span><span class="org-comment">extract unique player id</span>
        all_ids.append(player_id)

    <span class="org-variable-name">df</span> = pd.DataFrame(all_stats, columns=stat_cols).set_index(<span class="org-string">'player'</span>)
    <span class="org-variable-name">df</span>[<span class="org-string">'player_id'</span>] = all_ids

    <span class="org-keyword">return</span> df

<span class="org-keyword">def</span> <span class="org-function-name">process_scraped_table</span>(df, season):
    <span class="org-doc">"Drop redundant columns, add year column, update index. Return DataFrame."</span>
    <span class="org-variable-name">nunique</span> = df.<span class="org-builtin">apply</span>(pd.Series.nunique)
    <span class="org-variable-name">drop_cols</span> = nunique[nunique == 1].index
    df.drop(drop_cols, axis=1, inplace=<span class="org-constant">True</span>)
    <span class="org-variable-name">df</span>[<span class="org-string">'year'</span>] = [season] * <span class="org-builtin">len</span>(df)
    <span class="org-variable-name">df.index</span> += f<span class="org-string">' {str(season)}'</span>
    <span class="org-keyword">return</span> df

<span class="org-keyword">def</span> <span class="org-function-name">combine_season_stats</span>(dfs):
    <span class="org-doc">"Merge the stat tables from the same season on player ids."</span>
    <span class="org-variable-name">dfs</span> = [df.reset_index().set_index(<span class="org-string">'player_id'</span>) <span class="org-keyword">for</span> df <span class="org-keyword">in</span> dfs]
    <span class="org-variable-name">season_df</span> = <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> left, right: pd.merge(left, right[right.columns.difference(left.columns)], left_index=<span class="org-constant">True</span>, right_index=<span class="org-constant">True</span>), dfs)
    <span class="org-keyword">return</span> season_df.reset_index().set_index(<span class="org-string">'player'</span>)

<span class="org-keyword">def</span> <span class="org-function-name">scrape</span>(seasons, stat_types, data_dir):
    <span class="org-doc">"""</span>
<span class="org-doc">    Scrape player season stats from basketball reference for the given stat types</span>
<span class="org-doc">    across the given seasons and write out csv to given directory. Return DataFrame.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">options</span> = webdriver.firefox.options.Options()
    <span class="org-variable-name">options.headless</span> = <span class="org-constant">True</span>
    <span class="org-variable-name">browser</span> = webdriver.Firefox(executable_path=<span class="org-string">"scraping/drivers/geckodriver"</span>, options=options)
    <span class="org-variable-name">dfs</span> = []

    <span class="org-keyword">for</span> season <span class="org-keyword">in</span> seasons:
        <span class="org-keyword">print</span>(<span class="org-string">'scraping:'</span>, season)
        <span class="org-variable-name">season_dfs</span> = []
        select_season(browser, season); time.sleep(3)

        <span class="org-keyword">for</span> stat_type <span class="org-keyword">in</span> stat_types:
            select_stat_table(browser, stat_type); time.sleep(3)
            <span class="org-variable-name">page_source</span> = browser.page_source
            <span class="org-variable-name">soup</span> = BeautifulSoup(page_source, <span class="org-string">'html.parser'</span>)
            <span class="org-variable-name">df</span> = read_stat_table(soup)
            <span class="org-variable-name">df</span> = process_scraped_table(df, season)
            <span class="org-variable-name">filename</span> = data_dir + <span class="org-builtin">str</span>(season) + <span class="org-string">'_'</span> + <span class="org-builtin">str</span>(stat_type).replace(<span class="org-string">' '</span>, <span class="org-string">'_'</span>) + <span class="org-string">'.csv'</span>
            df.to_csv(filename)
            season_dfs.append(df)

        <span class="org-variable-name">combo_season_df</span> = combine_season_stats(season_dfs)
        <span class="org-variable-name">filename</span> = data_dir + <span class="org-builtin">str</span>(season) + <span class="org-string">'_'</span> + <span class="org-string">'_'</span>.join(stat_types) + <span class="org-string">'.csv'</span>
        combo_season_df.to_csv(filename)
        dfs.append(combo_season_df)

    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(seasons) &lt; 2:
        <span class="org-keyword">return</span> dfs[0]

    <span class="org-variable-name">master_df</span> = pd.concat(dfs)
    <span class="org-variable-name">filename</span> = data_dir + <span class="org-builtin">str</span>(seasons[0]) + <span class="org-string">'_to_'</span> + <span class="org-builtin">str</span>(seasons[-1]) + <span class="org-string">'_'</span> + <span class="org-string">'_'</span>.join(stat_types) + <span class="org-string">'.csv'</span>
    master_df.to_csv(filename)

    <span class="org-keyword">return</span> master_df
</pre>
</div>

<p>
Execute scraping:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> bball_ref_scraping_funcs <span class="org-keyword">import</span> scrape

<span class="org-variable-name">data_dir</span> = <span class="org-string">'nba_data/'</span>
<span class="org-variable-name">seasons</span> = [year <span class="org-keyword">for</span> year <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1997, 2021)]
<span class="org-variable-name">stat_types</span> = [<span class="org-string">'advanced'</span>, <span class="org-string">'shooting'</span>, <span class="org-string">'pbp'</span>, <span class="org-string">'per_poss'</span>]

<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> == <span class="org-string">'__main__'</span>:
    scrape(seasons, stat_types, data_dir)
</pre>
</div>

</details>
</div>
</div>

<div id="outline-container-orgf7f03fd" class="outline-3">
<h3 id="3.2.-cleaning-the-data">3.2. Cleaning the data</h3>
<div class="outline-text-3" id="text-3.2.-cleaning-the-data">
<p>
At this point the raw player dataset had shape <code>(11162, 92)</code> with rows of individual player-seasons and stat columns. After imposing a minutes threshold of 650 minutes the dataset was reduced to <code>(7363, 92)</code>. After filling in some straightforward NaNs I took a look at the remaining missing values to see if there were any anomalies in data collection:
</p>


<div class="figure">
<p><img src="../../assets/nba-clustering/stat_plots/missing_vals_by_year.jpg" alt="missing_vals_by_year.jpg" width="100%" />
</p>
</div>

<ul class="org-ul">
<li>Observations:
<ul class="org-ul">
<li>Early <code>drawn_offensive</code> data is mostly missing</li>
<li>Salary information is missing for all of 2020 and for a few other rows throughout</li>
<li>All other missing data is related to shooting percentages or shooting location
<ul class="org-ul">
<li>Noticeable decrease in missing values for percentages related to 3-point shooting as more players began to shoot from deep in recent seasons</li>
</ul></li>
</ul></li>

<li>Solutions:
<ul class="org-ul">
<li>Drop <code>drawn_offensive</code></li>
<li>impute missing salary data with <code>"missing"</code></li>
<li>Verify missing shooting data and fill with 0s
<ul class="org-ul">
<li>i.e. check that missing value for <code>fg_pct_00_03</code> reflects that a player took 0 attempts from specified region and is not otherwise anomalous</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org5dce7ef" class="outline-3">
<h3 id="3.3.-transforming-the-data">3.3. Transforming the data</h3>
<div class="outline-text-3" id="text-3.3.-transforming-the-data">
<p>
To prepare the dataset for dimensionality reduction and clustering some further steps were taken:
</p>

<ul class="org-ul">
<li>Drop seasons prior to 2000 given sketchy play-by-play data</li>
<li>Remove some highly correlated stats (&gt; 95% correlation)</li>
<li>Log transform 22 columns</li>
<li>Clip 3-point related percentages for very low volume 3-point shooting
players with outlier percentages to help differentiate great shooters

<ul class="org-ul">
<li>e.g. Clip a player's 75% 3-point shooting percentage if it came on
less than 1 3-point attempt per 100 possessions to better reflect
the player's shooting ability</li>
</ul></li>

<li>Drop <code>year</code> and <code>nationality</code></li>
<li>Scale with <code>sklearn.StandardScaler</code></li>
</ul>

<details>

<summary>
<i>ALL positive numeric initial stat distributions</i>
</summary>


<div class="figure">
<p><img src="../../assets/nba-clustering/stat_plots/stat_distributions_1997_to_2020_box_hist.jpg" alt="stat_distributions_1997_to_2020_box_hist.jpg" width="100%" />
</p>
</div>

</details>
</div>
</div>

<div id="outline-container-org559ddf0" class="outline-3">
<h3 id="3.4.-principal-component-analysis-(PCA)">3.4. Principal component analysis (PCA)</h3>
<div class="outline-text-3" id="text-3.4.-principal-component-analysis-(PCA)">
<p>
After dropping some more columns (e.g. <code>age</code>, stats related to traditional positions, etc.) I used PCA to further transform the data into a more easily separable space and reduce the dimensionality from 48 dimensions to 29 dimensions while retaining 99% of the variance within the dataset.
</p>


<div class="figure">
<p><img src="../../assets/nba-clustering/pca_plots/pca_explained_variance.jpg" alt="pca_explained_variance.jpg" width="75%;" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcee6951" class="outline-2">
<h2 id="4.-Clustering">4. Clustering</h2>
<div class="outline-text-2" id="text-4.-Clustering">
<p>
After experimenting with k-means and DBSCAN clustering I settled on using a gaussian mixture model (GMM) and expectation-maximization (EM) algorithm to generate 12 cluster probabilities for each player-season. The ability of GMMs to identify clusters with arbitrarily shaped densities and the nuance of probabilistic cluster labels, compared with hard cluster labels, were both attractive. However, most player-seasons belong to a single cluster with high probability. <sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>
</p>

<details>

  <summary>
<i>Generate cluster labels (sklearn)</i>
  </summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">from</span> sklearn.mixture <span class="org-keyword">import</span> GaussianMixture

<span class="org-variable-name">df</span> = pd.read_csv(<span class="org-string">'../datasets/pca99_2000_2020.csv'</span>, index_col=0)
<span class="org-variable-name">seed</span> = 3
<span class="org-variable-name">n_comps</span> = 12
<span class="org-variable-name">gmm</span> = GaussianMixture(n_components=n_comps,
                      covariance_type=<span class="org-string">'full'</span>,
                      max_iter=10_000,
                      n_init=8,
                      random_state=seed)
gmm.fit(df)
<span class="org-variable-name">hard_labels</span> = gmm.predict(df)
<span class="org-variable-name">soft_labels</span> = gmm.predict_proba(df)
<span class="org-variable-name">df_clusters</span> = pd.DataFrame(hard_labels, index=df.index, columns=[<span class="org-string">'label'</span>])
<span class="org-variable-name">soft_cols</span> = [f<span class="org-string">'cluster_{n}'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(gmm.n_components)]
<span class="org-variable-name">df_clusters</span>[soft_cols] = soft_labels
df_clusters.head()  <span class="org-comment-delimiter"># </span><span class="org-comment">image below</span>
</pre>
</div>

</details>


<div class="figure">
<p><img src="../../assets/nba-clustering/clustering_df_head.jpg" alt="clustering_df_head.jpg" width="100%" />
</p>
</div>
</div>

<div id="outline-container-org44b2d9b" class="outline-3">
<h3 id="4.1.-clusters-overview">4.1. Clusters overview</h3>
<div class="outline-text-3" id="text-4.1.-clusters-overview">
<p>
All the statistical, biographical, pca, and cluster label datasets were combined into a single dataset to help isolate interesting features about the clusters. To begin differentiating them I looked for the major areas of statistical difference between and within clusters. Using plots like the one following the table below, I determined the defining features of each cluster and came up with representative names for each cluster which appear below.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Cluster</th>
<th scope="col" class="org-right">Count</th>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Sample Seasons</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">327</td>
<td class="org-left">Reserve Bigs</td>
<td class="org-left">Enes Kanter 20', Tiago Splitter 14', Glen Davis 12, Tyrus Thomas 07'</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">852</td>
<td class="org-left">Secondary Wings (3&amp;D)</td>
<td class="org-left">Jae Crowder 19', Shane Battier 14', Rick Fox 01', James Posey 00'</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">241</td>
<td class="org-left">Effective Skilled Bigs</td>
<td class="org-left">LaMarcus Aldridge 14', Chris Bosh 13', Pau Gasol 06', Vlade Divac 01'</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">635</td>
<td class="org-left">Effective Lead Ball Handlers</td>
<td class="org-left">Ja Morant 20', Chris Paul 12', Jameer Nelson 07', Jason Kidd 2002</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">142</td>
<td class="org-left">Traditional Centers</td>
<td class="org-left">Hassan Whiteside 20', DeAndre Jordan 12', Dwight Howard 10', Ben Wallace 08'</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">604</td>
<td class="org-left">Passing Offensive Initiators</td>
<td class="org-left">J.J. Barea 19', Rajon Rondo 15', Luke Ridnour 08', Damon Stoudamire 03'</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">635</td>
<td class="org-left">Scoring Focused Guards</td>
<td class="org-left">Lou Williams 20', Nick Young 13', Jason Terry 09', Steve Francis 07'</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">1,001</td>
<td class="org-left">Variety Post Bigs</td>
<td class="org-left">Ed Davis 18', Joakim Noah 17', Kenneth Faried 13', Leon Powe 09'</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">675</td>
<td class="org-left">Variety Wings &amp; Stretch Bigs</td>
<td class="org-left">Kelly Olynyk 19', Omri Casspi 15', Josh Childress 08', Gerald Wallace 06'</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">326</td>
<td class="org-left">High Usage/Scoring/Impact Stars</td>
<td class="org-left">LeBron James 20', James Harden 18', Tracy McGrady 05', Kevin Garnett 04',</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">403</td>
<td class="org-left">Variety Ball handlers</td>
<td class="org-left">Boris Diaw 17', Kyle Anderson 16', Shaun Livingston 14', Michael Beasley 13'</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">703</td>
<td class="org-left">3pt Specialists &amp; Low-impact Reserve Wings/Forwards</td>
<td class="org-left">Ben McLemore 20', Matt Bonner 11', Jason Kapono 11', Luke Walton 09'</td>
</tr>
</tbody>
</table>


<div class="figure">
<p><img src="../../assets/nba-clustering/cluster_plots/cluster_mean_stats_snapshot.jpg" alt="cluster_mean_stats_snapshot.jpg" width="100%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org11daee5" class="outline-3">
<h3 id="4.2.-PCA-plots-to-visualize-cluster-spacing">4.2. PCA plots to visualize cluster spacing</h3>
<div class="outline-text-3" id="text-4.2.-PCA-plots-to-visualize-cluster-spacing">
<p>
To get a rough visual intuition for the relative spacing of the clusters I plotted player-seasons according to their major principal components from the earlier PCA. Sizing the data points by box-plus minus provides further information about the box score impact that players from each cluster tend to have; principal component number 1 appears to have a near linear relationship with box-plus minus in the two-dimensional plot. The relative player-season spacing highlighted by the annotations makes intuitive sense to a basketball fan like myself. Polar opposite players such as Mike Miller and Shaquille O'Neal should be very widely spread out, and we do see that below.
</p>


<div class="figure">
<p><img src="../../assets/nba-clustering/pca_plots/pca_players_annotated.jpg" alt="pca_players_annotated.jpg" width="100%" />
</p>
</div>


<div class="figure">
<p><img src="../../assets/nba-clustering/pca_plots/3d/pca_3d_first.png" alt="pca_3d_first.png" width="60%" style="float:left;padding-top: 7rem;" />
</p>
</div>

<div class="figure">
<p><img src="../../assets/nba-clustering/pca_plots/3d/pca_3d_second.png" alt="pca_3d_second.png" width="37%" style="float:right;" />
</p>
</div>

<div class="figure">
<p><img src="../../assets/nba-clustering/pca_plots/3d/pca_3d_third.png" alt="pca_3d_third.png" width="37%" style="float:right;" />
</p>
</div>
<div class="clear"></div>
</div>
</div>


<div id="outline-container-orga2de361" class="outline-3">
<h3 id="4.3.-clusters-vs-traditional-positions">4.3. Clusters vs traditional positions</h3>
<div class="outline-text-3" id="text-4.3.-clusters-vs-traditional-positions">
<p>
One of the first comparisons I looked into was the relationship between the clusters and the traditional positions. Using play-by-play data that provides the percentage of minutes a player plays at each traditional lineup position I compared how the clusters and traditional positions overlap. Below we see that only three clusters (4,5,7) spend a majority of their time at a single position. It is unsurprising that the strongest cluster and position relationships are between centers and point guards, as these two positions have the most differentiated set of roles among the five traditional positions. Still, centers and point guards are far from homogenous groups and both are well-represented across several clusters each.
</p>


<div class="figure">
<p><img src="../../assets/nba-clustering/cluster_plots/percent_playing_time_at_position.jpg" alt="percent_playing_time_at_position.jpg" width="100%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org3ed6edd" class="outline-3">
<h3 id="4.4.-finances-&-player-counts">4.4. Finances &amp; player counts</h3>
<div class="outline-text-3" id="text-4.4.-finances-&-player-counts">
<p>
Money talks, and in the NBA it speaks to which players NBA front offices value and believe contribute to winning basketball games. Contracts in the NBA are constrained by a soft spending cap on team spending each year, <sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup> as well as rules defining the minimum and maximum amounts that players at different stages of their career can earn. As the league changes, so to does the types of players who get paid the most.
</p>


<div class="figure">
<p><img src="../../assets/nba-clustering/cluster_plots/mean_cluster_salary.jpg" alt="mean_cluster_salary.jpg" width="48%" style="float:left;" />
</p>
</div>

<div class="figure">
<p><img src="../../assets/nba-clustering/cluster_plots/number_players_per_cluster_each_year.jpg" alt="number_players_per_cluster_each_year.jpg" width="48%" style="float:right;" />
</p>
</div>
<div class="clear"></div>


<p>
The growth of mean salaries for clusters 9 ("high impact stars") and 3 ("effective lead ball handlers) stands out when looking at the mean salaries for each cluster from 2000-2019. This mirrors the known trend towards versatile guards and wings and away from traditional post-centric offensive anchors. Clusters 9 and 3 are indeed composed of well-known and coveted players, and looking at the statistical snapshot from earlier we see that these two clusters are leaders in box plus/minus. Teams appear willing to pay more today for the most impactful players; current payrolls are more aligned with the conventional wisdom that the NBA is a star-dominated league.
</p>

<p>
Looking at the number of players in each cluster by year we see further evidence for the demise of the traditional big man. Cluster 0 ("reserve bigs") and cluster 7 ("variety post bigs") have seen their numbers fall considerably in the last 20 years. However, there remains a solid contingent of "traditional centers" in the league even while the overall influence of post-bigs wanes; players like Hassan Whiteside and DeAndre Jordan. On the rise are clusters with positive shooting attributes: cluster 1 ("secondary wings (3&amp;D)"), cluster 8 ("variety wings &amp; stretch forwards"), and cluster 11 ("3pt specialists &amp; low-impact reserve wings/forwards").
</p>

<p>
There are very few player-season representing cluster 10 ("variety ball handlers") and cluster 2 ("effective skilled bigs") in the most recent seasons. The types of player-seasons in these two clusters may simply not be well-represented in the modern NBA. For example, players who we may consider the next iteration of someone like Toronto Chris Bosh (cluster 2 and 9) almost definitely takes 3-pointers today and generally plays a game more tailored towards today's trends, perhaps precluding them from membership in cluster 2.
</p>
</div>
</div>
</div>

<div id="outline-container-org48f1616" class="outline-2">
<h2 id="5.-Lineup-analysis">5. Lineup Analysis</h2>
<div class="outline-text-2" id="text-5.-Lineup-analysis">
</div>
<div id="outline-container-orgb3fdb0b" class="outline-3">
<h3 id="5.1.-scraping-lineup-data">5.1. Scraping lineup data</h3>
<div class="outline-text-3" id="text-5.1.-scraping-lineup-data">
<p>
To acquire the lineup data I turned again to <a href="https://www.basketball-reference.com/players/i/iversal01.html">basketball reference</a> which maintains statistics for 5-player, 4-player, 3-player, and 2-player lineup combinations going back to the 1996-97 season. I gathered all the lineup data for every 5 and 4 player lineup from 1996-97 through 2019-20. One nuance in scraping the lineup data was the need to be aware of team name transitions and relocations given that the lineup data is housed within franchise pages. After scraping the data I immediately applied minutes thresholds of 150 for 5-player lineups and 300 for 4-player lineups. After adding some columns like <code>number_players</code>, <code>team</code>, <code>year</code>, <code>player_ids</code> to the lineup datasets, the initial datasets had shape <code>(1964, 27)</code> for 5-player lineups and <code>(5977, 27)</code> for 4-player lineups.
</p>

<details>

<summary>
<i>Lineup scraping code</i>
</summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">select_team_and_year_lineups</span>(browser, team, year):
    <span class="org-doc">"Navigate browser to given franchise page and year."</span>
    <span class="org-variable-name">url</span> = f<span class="org-string">'https://www.basketball-reference.com/teams/{team}/{year}/lineups/'</span>
    browser.get(url)

<span class="org-keyword">def</span> <span class="org-function-name">read_lineup_table</span>(soup, n_man_lineup):
    <span class="org-doc">"""</span>
<span class="org-doc">    Parse the html lineup stat table for the lineup type given by n_man_lineup</span>
<span class="org-doc">    (i.e. 4-player or 5-player lineups) on the current bs4 object page.</span>
<span class="org-doc">    Return DataFrame.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">all_stats</span>, <span class="org-variable-name">all_lineup_ids</span>, <span class="org-variable-name">stat_cols</span> = [], [], []
    <span class="org-variable-name">table</span> = soup.find(<span class="org-string">'table'</span>, {<span class="org-string">'id'</span>: f<span class="org-string">'lineups_{n_man_lineup}-man_'</span>})
    <span class="org-variable-name">tbody</span> = table.find(<span class="org-string">'tbody'</span>)

    <span class="org-keyword">for</span> row <span class="org-keyword">in</span> tbody.find_all(<span class="org-string">'tr'</span>)[0:-1]:
        <span class="org-variable-name">cols</span> = row.find_all(<span class="org-string">'td'</span>)
        <span class="org-variable-name">stat_cols</span> = [col.get(<span class="org-string">'data-stat'</span>) <span class="org-keyword">for</span> col <span class="org-keyword">in</span> cols]

        <span class="org-variable-name">lineup_ids</span> = [cols[0].get(<span class="org-string">'csk'</span>)]
        all_lineup_ids.append(lineup_ids)

        <span class="org-variable-name">lineup_stats</span> = [col.text <span class="org-keyword">for</span> col <span class="org-keyword">in</span> cols]
        all_stats.append(lineup_stats)

    <span class="org-variable-name">df</span> = pd.DataFrame(all_stats, columns=stat_cols).set_index(<span class="org-string">'lineup'</span>)
    <span class="org-variable-name">df</span>[<span class="org-string">'player_ids'</span>] = all_lineup_ids
    <span class="org-variable-name">df</span>[<span class="org-string">'number_players'</span>] = [n_man_lineup] * <span class="org-builtin">len</span>(df)

    <span class="org-keyword">return</span> df

<span class="org-keyword">def</span> <span class="org-function-name">process_lineup_df</span>(df, team, year):
    <span class="org-doc">"""</span>
<span class="org-doc">    Process the extracted lineup stat table:</span>
<span class="org-doc">      - Convert minutes played to numeric datatype</span>
<span class="org-doc">      - Fill blanks with NaNs</span>
<span class="org-doc">      - Convert differential stats to floats</span>
<span class="org-doc">      - Add year and team columns</span>
<span class="org-doc">      - Update index to reflect players, team, and year</span>

<span class="org-doc">    Return DataFrame.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">df.loc</span>[:, <span class="org-string">'mp'</span>] = df[<span class="org-string">'mp'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-builtin">float</span>(x.split(<span class="org-string">':'</span>)[0]) + <span class="org-builtin">float</span>(x.split(<span class="org-string">':'</span>)[1])/60)
    <span class="org-variable-name">df.loc</span>[:, <span class="org-string">'player_ids'</span>] = df[<span class="org-string">'player_ids'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x[0].replace(<span class="org-string">':'</span>, <span class="org-string">', '</span>))
    df.replace(<span class="org-string">''</span>, np.nan)
    <span class="org-variable-name">conv_to_float_cols</span> = df.columns[df.columns.<span class="org-builtin">str</span>.contains(<span class="org-string">'diff'</span>)]
    <span class="org-variable-name">df.loc</span>[:, conv_to_float_cols] = df[conv_to_float_cols].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> series: pd.to_numeric(series, errors=<span class="org-string">'ignore'</span>))
    <span class="org-variable-name">df</span>[<span class="org-string">'year'</span>] = [year] * <span class="org-builtin">len</span>(df)
    <span class="org-variable-name">df</span>[<span class="org-string">'team'</span>] = [team] * <span class="org-builtin">len</span>(df)
    <span class="org-variable-name">df.index</span> = df.index + f<span class="org-string">' {team} {year}'</span>

    <span class="org-keyword">return</span> df

<span class="org-keyword">def</span> <span class="org-function-name">scrape_lineup_data</span>(teams, seasons, n_man_lineup, data_dir):
    <span class="org-doc">"""</span>
<span class="org-doc">    Scrape lineup data from basketball reference for given teams and seasons</span>
<span class="org-doc">    for the given lineup type (i.e. 4-player or 5-player lineups). Write out team</span>
<span class="org-doc">    lineup DataFrames and combined DataFrame to the given data directory.</span>
<span class="org-doc">    Return combined DataFrame.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">options</span> = webdriver.firefox.options.Options()
    <span class="org-variable-name">options.headless</span> = <span class="org-constant">True</span>
    <span class="org-variable-name">browser</span> = webdriver.Firefox(executable_path=<span class="org-string">"scraping/drivers/geckodriver"</span>, options=options)
    <span class="org-variable-name">start</span> = datetime.now()
    <span class="org-variable-name">all_dfs</span> = []
    <span class="org-keyword">for</span> team <span class="org-keyword">in</span> teams:
        <span class="org-variable-name">team_dfs</span> = []
        <span class="org-keyword">print</span>(<span class="org-string">'scraping:'</span>, team, <span class="org-string">'   |   '</span>, datetime.now()-start)
        <span class="org-keyword">for</span> season <span class="org-keyword">in</span> seasons:
            <span class="org-comment-delimiter"># </span><span class="org-comment">handle team name switches etc.</span>
            <span class="org-keyword">if</span> team == <span class="org-string">'NJN'</span> <span class="org-keyword">and</span> season &gt; 2012: <span class="org-variable-name">team</span> = <span class="org-string">'BRK'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'NOH'</span> <span class="org-keyword">and</span> season &lt; 2003: <span class="org-keyword">continue</span> <span class="org-comment-delimiter"># </span><span class="org-comment">not a team prior to 2002-03</span>
            <span class="org-keyword">if</span> team == <span class="org-string">'NOH'</span> <span class="org-keyword">and</span> season == 2006: <span class="org-variable-name">team</span> = <span class="org-string">'NOK'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'NOK'</span> <span class="org-keyword">and</span> season == 2008: <span class="org-variable-name">team</span> = <span class="org-string">'NOH'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'NOH'</span> <span class="org-keyword">and</span> season == 2014: <span class="org-variable-name">team</span> = <span class="org-string">'NOP'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'SEA'</span> <span class="org-keyword">and</span> season &gt; 2008: <span class="org-variable-name">team</span> = <span class="org-string">'OKC'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'WSB'</span> <span class="org-keyword">and</span> season &gt; 1997: <span class="org-variable-name">team</span> = <span class="org-string">'WAS'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'CHH'</span> <span class="org-keyword">and</span> season &gt; 2002: <span class="org-variable-name">team</span> = <span class="org-string">'CHA'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'CHA'</span> <span class="org-keyword">and</span> season <span class="org-keyword">in</span> [2002, 2003, 2004]: <span class="org-keyword">continue</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">no charlotte team 2002-2004</span>
            <span class="org-keyword">if</span> team == <span class="org-string">'CHA'</span> <span class="org-keyword">and</span> season &gt; 2014: <span class="org-variable-name">team</span> = <span class="org-string">'CHO'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)
            <span class="org-keyword">if</span> team == <span class="org-string">'VAN'</span> <span class="org-keyword">and</span> season &gt; 2001 : <span class="org-variable-name">team</span> = <span class="org-string">'MEM'</span>; <span class="org-keyword">print</span>(<span class="org-string">'Season:'</span>, season, <span class="org-string">'--&gt;'</span>, team)

            select_team_and_year_lineups(browser, team, season)
            <span class="org-variable-name">page_source</span> = browser.page_source
            <span class="org-variable-name">soup</span> = BeautifulSoup(page_source, <span class="org-string">'html.parser'</span>)
            <span class="org-variable-name">df</span> = read_lineup_table(soup, n_man_lineup)
            <span class="org-variable-name">df</span> = process_lineup_df(df, team, season)
            team_dfs.append(df)

        <span class="org-variable-name">combined_team_df</span> = pd.concat(team_dfs)
        <span class="org-variable-name">filename</span> = data_dir + f<span class="org-string">'{team}/{team}_{n_man_lineup}_man_lineups_{seasons[0]}_{seasons[-1]}.csv'</span>
        os.makedirs(os.path.dirname(filename), exist_ok=<span class="org-constant">True</span>)
        combined_team_df.to_csv(filename)
        all_dfs.append(combined_team_df)

    <span class="org-variable-name">df</span> = pd.concat(all_dfs)
    <span class="org-variable-name">filename</span> = f<span class="org-string">'bballref_data/raw_all_teams_{n_man_lineup}_man_lineups_{seasons[0]}_{seasons[-1]}.csv'</span>
    df.to_csv(filename)
    <span class="org-keyword">return</span> df
</pre>
</div>

<p>
Execute scraping:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> bballref_lineup_scraping_funcs <span class="org-keyword">import</span> scrape_lineup_data

<span class="org-variable-name">data_dir</span> = <span class="org-string">'bballref_data/lineups/'</span>
<span class="org-variable-name">n_man_lineup</span> = 5
<span class="org-variable-name">seasons</span> = [year <span class="org-keyword">for</span> year <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1997, 2021)]
<span class="org-variable-name">teams</span> = [
        <span class="org-string">'ATL'</span>,
        <span class="org-string">'NJN'</span>,  <span class="org-comment-delimiter"># </span><span class="org-comment">switches to BKN</span>
        <span class="org-string">'BOS'</span>,
        <span class="org-string">'CHH'</span>,  <span class="org-comment-delimiter"># </span><span class="org-comment">switches to CHA then CHO</span>
        <span class="org-string">'CHI'</span>,
        <span class="org-string">'CLE'</span>,
        <span class="org-string">'DAL'</span>,
        <span class="org-string">'DEN'</span>,
        <span class="org-string">'DET'</span>,
        <span class="org-string">'GSW'</span>,
        <span class="org-string">'HOU'</span>,
        <span class="org-string">'IND'</span>,
        <span class="org-string">'LAC'</span>,
        <span class="org-string">'LAL'</span>,
        <span class="org-string">'VAN'</span>,  <span class="org-comment-delimiter"># </span><span class="org-comment">switches to MEM</span>
        <span class="org-string">'MIA'</span>,
        <span class="org-string">'MIL'</span>,
        <span class="org-string">'MIN'</span>,
        <span class="org-string">'NOH'</span>,  <span class="org-comment-delimiter"># </span><span class="org-comment">switches to NOP</span>
        <span class="org-string">'NYK'</span>,
        <span class="org-string">'SEA'</span>,  <span class="org-comment-delimiter"># </span><span class="org-comment">switches to OKC</span>
        <span class="org-string">'ORL'</span>,
        <span class="org-string">'PHI'</span>,
        <span class="org-string">'PHO'</span>,
        <span class="org-string">'POR'</span>,
        <span class="org-string">'SAC'</span>,
        <span class="org-string">'SAS'</span>,
        <span class="org-string">'TOR'</span>,
        <span class="org-string">'UTA'</span>,
        <span class="org-string">'WSB'</span>, <span class="org-comment-delimiter"># </span><span class="org-comment">switches to WAS</span>
        ]

<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> == <span class="org-string">'__main__'</span>:
    scrape_lineup_data(teams, seasons, n_man_lineup, data_dir)
</pre>
</div>

</details>


<div class="figure">
<p><img src="../../assets/nba-clustering/5_player_raw_lineup_head_tail.jpg" alt="5_player_raw_lineup_head_tail.jpg" width="100%;" />
</p>
</div>
</div>
</div>

<div id="outline-container-org68c2707" class="outline-3">
<h3 id="5.2.-building-lineup-cluster-profiles">5.2. Building lineup cluster profiles</h3>
<div class="outline-text-3" id="text-5.2.-building-lineup-cluster-profiles">
<p>
Each lineup in the final lineup dataset has a cluster profile that is a summation of the individual cluster profiles of the players in the lineup. More than five clusters can be represented in each lineup given the soft probabilistic labels produced by the Gaussian Mixture Model. In addition to the straightforward lineup cluster profiles, I created bpm-weighted lineup cluster profiles. The bpm-weighted cluster profiles simply weight each player-season's cluster profile by the player-season bpm before adding it to the lineup cluster profile. The bpm-weighted cluster profile is meant to provide context about where a lineup's strengths and weaknesses lie with respect to the clusters.
</p>

<p>
Building the lineup dataset with cluster profiles requires 2 steps. First, verify the validity of each lineup with reference to the player dataset. Second, sum the cluster profiles of each player in a particular lineup and produce the lineup cluster profiles.
</p>

<details>

<summary>
<i>Functions for verifying and building lineup cluster profiles</i>
</summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">verify_players</span>(lineup, df_players):
    <span class="org-doc">"""</span>
<span class="org-doc">    Return a boolean indicating whether all players in given lineup are</span>
<span class="org-doc">    present in the provided player dataset.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">player_ids</span> = lineup[<span class="org-string">'player_ids'</span>].split(<span class="org-string">', '</span>)
    <span class="org-variable-name">year</span> = lineup[<span class="org-string">'year'</span>]

    <span class="org-keyword">for</span> pid <span class="org-keyword">in</span> player_ids:
        <span class="org-keyword">if</span> df_players[(df_players[<span class="org-string">'year'</span>]==year) &amp;
            (df_players[<span class="org-string">'player_id'</span>]==pid)].empty:
            <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">return</span> <span class="org-constant">True</span>

<span class="org-keyword">def</span> <span class="org-function-name">get_lineup_cluster_profile</span>(lineup, df_players):
    <span class="org-doc">"""</span>
<span class="org-doc">    Build the plain lineup cluster profile and bpm-weighted lineup cluster</span>
<span class="org-doc">    profiles by summing the individual player cluster labels across all players</span>
<span class="org-doc">    in the given lineup.</span>

<span class="org-doc">    Return a (1x24) np array of 12 bpm-weighted cluster labels and 12 plain</span>
<span class="org-doc">    cluster labels.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">player_ids</span> = lineup[<span class="org-string">'player_ids'</span>].split(<span class="org-string">', '</span>)
    <span class="org-variable-name">year</span> = lineup[<span class="org-string">'year'</span>]
    <span class="org-variable-name">cluster_bpm_cols</span> = [f<span class="org-string">'cluster_{n}_bpm'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(12)]
    <span class="org-variable-name">cluster_nonbpm_cols</span> = [f<span class="org-string">'cluster_{n}'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(12)]

    <span class="org-variable-name">lineup_bpm_clusters</span> = np.zeros(12)
    <span class="org-variable-name">lineup_nonbpm_clusters</span> = np.zeros(12)

    <span class="org-keyword">for</span> pid <span class="org-keyword">in</span> player_ids:
        <span class="org-variable-name">player</span> = df_players[(df_players[<span class="org-string">'year'</span>] == year) &amp; (df_players[<span class="org-string">'player_id'</span>] == pid)]
        <span class="org-variable-name">lineup_bpm_clusters</span> += player[cluster_bpm_cols].to_numpy().reshape(-1)
        <span class="org-variable-name">lineup_nonbpm_clusters</span> += player[cluster_nonbpm_cols].to_numpy().reshape(-1)

    <span class="org-keyword">return</span> np.append(lineup_bpm_clusters, lineup_nonbpm_clusters)
</pre>
</div>

</details>

<details>

<summary>
<i>Build lineup dataset with cluster profiles</i>
</summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">## </span><span class="org-comment">Building 4man lineups (same process for 5-man lineups)</span>
<span class="org-variable-name">df_players</span> = pd.read_csv(<span class="org-string">'datasets/master_player_stats_bio_bpm_clusters.csv'</span>, index_col=0)
<span class="org-variable-name">df_all_4</span> = pd.read_csv(<span class="org-string">'datasets/lineups/4man_lineups_300min_1997_2020.csv'</span>, index_col=0)
<span class="org-variable-name">df_all_4</span> = df_all_4[df_all_4[<span class="org-string">'year'</span>] &gt;=2000]

<span class="org-comment-delimiter">## </span><span class="org-comment">Drop invalid lineups with players who are not in the player dataset</span>
<span class="org-variable-name">indices</span> = df_all_4.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> lineup: verify_players(lineup, df_players), axis=1)
<span class="org-variable-name">df4</span> = df_all_4.loc[indices[indices==<span class="org-constant">True</span>].index, :]

<span class="org-comment-delimiter">## </span><span class="org-comment">Construct pd.Series with lineup cluster profiles as values and same index as df4</span>
<span class="org-variable-name">lineup_cluster_profile_series</span> = df4.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> lineup: get_lineup_cluster_profile(lineup, df_players), axis=1)
<span class="org-variable-name">lineup_cluster_profiles</span> = lineup_cluster_profile_series.values
<span class="org-variable-name">lineup_cluster_profiles</span> = [[val <span class="org-keyword">for</span> val <span class="org-keyword">in</span> lineup_cluster_profiles[row]] <span class="org-keyword">for</span>
                            row <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(lineup_cluster_profiles))]

<span class="org-comment-delimiter">## </span><span class="org-comment">Add the cluster profiles to the lineup dataset, write out</span>
<span class="org-variable-name">cluster_bpm_cols</span> = [f<span class="org-string">'cluster_{n}_bpm'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(12)]
<span class="org-variable-name">cluster_nonbpm_cols</span> = [f<span class="org-string">'cluster_{n}'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(12)]
<span class="org-variable-name">cols</span> = cluster_bpm_cols + cluster_nonbpm_cols
<span class="org-variable-name">df4</span>[cols] = lineup_cluster_profiles
df4.to_csv(<span class="org-string">'datasets/master_4man_lineup_clusters_2000_2020.csv'</span>)
</pre>
</div>

</details>
</div>
</div>

<div id="outline-container-org25d9b02" class="outline-3">
<h3 id="5.3.-lineup-correlations-&-salaries">5.3. Lineup correlations &amp; salaries</h3>
<div class="outline-text-3" id="text-5.3.-lineup-correlations-&-salaries">
<p>
Before trying to predict lineup point-differentials I attempted to gain some baseline insight into the lineup data with a standard correlation analysis as well as a look into how lineup salary and performance relate. Working with the 5-player dataset I isolated the ten lineup statistics with the highest correlation to point differential. Shooting the ball well is highly desirable. Surprise!
</p>


<div class="figure">
<p><img src="../../assets/nba-clustering/lineup_plots/lineup_10_correlated_stats_diff_pts.jpg" alt="lineup_10_correlated_stats_diff_pts.jpg" width="100%;" />
</p>
</div>

<p>
Do higher paid lineups perform better than lower paid ones? To compare the salaries of lineups across different years requires normalizing each lineup salary relative to its own year. After dropping lineups that included players that do not have salary information in the player dataset, I computed the total player salary of each lineup, league salary mean and standard deviation for the given year, and the salary z-score for each lineup.
</p>

<p>
\[Z = \frac{x-\mu_{year}}{\sigma_{year}}\]
</p>

<details>

<summary>
<i>Code</i>
</summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">get_lineup_salary</span>(lineup, df_players):
    <span class="org-variable-name">player_ids</span> = lineup[<span class="org-string">'player_ids'</span>].split(<span class="org-string">', '</span>)
    <span class="org-variable-name">year</span> = lineup[<span class="org-string">'year'</span>]
    <span class="org-variable-name">total_salary</span> = 0
    <span class="org-keyword">for</span> pid <span class="org-keyword">in</span> player_ids:
        <span class="org-variable-name">player</span> = df_players[(df_players[<span class="org-string">'year'</span>]==year) &amp; (df_players[<span class="org-string">'player_id'</span>]==pid)]
        <span class="org-variable-name">total_salary</span> += player[<span class="org-string">'salary'</span>].item()
    <span class="org-keyword">return</span> total_salary

<span class="org-keyword">def</span> <span class="org-function-name">get_salary_zscore</span>(lineup, yearly_salary_mu_sigma):
    <span class="org-variable-name">year</span> = lineup[<span class="org-string">'year'</span>]
    <span class="org-variable-name">mu</span>, <span class="org-variable-name">sigma</span> = yearly_salary_mu_sigma.loc[year].values
    <span class="org-keyword">return</span> (lineup[<span class="org-string">'total_salary'</span>] - mu) / sigma

<span class="org-comment-delimiter"># </span><span class="org-comment">df5 is the 5-player lineup dataset</span>
<span class="org-variable-name">yearly_mu_sigma</span> = df5.groupby(<span class="org-string">'year'</span>)[<span class="org-string">'total_salary'</span>].agg([<span class="org-string">'mean'</span>, <span class="org-string">'std'</span>])
<span class="org-variable-name">df5</span>[<span class="org-string">'total_salary'</span>] = df5.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> lineup: get_lineup_salary(lineup, df_players), axis=1)
<span class="org-variable-name">df5</span>[<span class="org-string">'salary_zscore'</span>] = df5.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> lineup: get_salary_zscore(lineup, yearly_mu_sigma), axis=1)
</pre>
</div>

</details>


<div class="figure">
<p><img src="../../assets/nba-clustering/lineup_plots/lineup_pts_diff_salary_zscores_annotated.jpg" alt="lineup_pts_diff_salary_zscores_annotated.jpg" width="100%;" />
</p>
</div>

<p>
A high lineup salary does not directly indicate high performance. However, there are several factors clouding this analysis of lineup salary and performance. The 150 minute threshold likely weeds out many poor performing lineups, as teams that want to win move on quickly from terrible lineup combinations, producing a strong bias towards better lineups accumulating more minutes. Opposite this minutes bias there are several reasons organizations play bad expensive lineups on purpose: allow young players to mature, improve draft odds by losing, and the ability to acquire future assets by taking on bloated contracts from teams that want to win now.
</p>
</div>
</div>

<div id="outline-container-org670bff1" class="outline-3">
<h3 id="5.4.-predicting-lineup-point-differentials">5.4. Predicting lineup point differentials</h3>
<div class="outline-text-3" id="text-5.4.-predicting-lineup-point-differentials">
<p>
With the lineup cluster profiles as inputs, I trained several simple artificial neural networks to try and predict the observed lineup point-differentials per 100 possessions. Each fully-connected feed-forward network takes in a 12 dimensional input (the cluster profile), outputs a scalar representing the predicted point differential for the lineup, and is trained to minimize the mean-squared error of predictions vs observed point-differentials.
</p>

<p>
Within 2,000 epochs the test loss for every network plateaued before rising due to overfitting. Deeper networks only accelerated the learning and overfitting, with no performance improvements over a small network with 2 hidden layers and 24 units in each. The best results were obtained training on 4-player lineups with bpm-weighted cluster profiles. The predictions by the best performing networks are not going to make anyone rich betting on the NBA. The MSE translates to an average error around 5.6 points per lineup, a wide margin that is enough to distinguish solid from terrible or great from good lineups. There does not appear to be enough information in the cluster profiles to accurately predict lineup success in the NBA.
</p>

<details>

<summary>
<i>Pytorch helper functions</i>
</summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> sklearn.model_selection <span class="org-keyword">import</span> train_test_split
<span class="org-keyword">import</span> torch
<span class="org-keyword">import</span> torch.nn <span class="org-keyword">as</span> nn


<span class="org-keyword">def</span> <span class="org-function-name">build_MLP</span>(sizes, activation, output_activation=nn.Identity):
    <span class="org-variable-name">layers</span> = []
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(sizes)-1):
        <span class="org-variable-name">active_fn</span> = activation <span class="org-keyword">if</span> i &lt; <span class="org-builtin">len</span>(sizes) - 2 <span class="org-keyword">else</span> output_activation
        <span class="org-variable-name">layers</span> += [nn.Linear(in_features=sizes[i], out_features=sizes[i+1]), active_fn()]
    <span class="org-variable-name">mlp</span> = nn.Sequential(*layers)
    <span class="org-keyword">return</span> mlp

<span class="org-keyword">def</span> <span class="org-function-name">torch_train_test_split</span>(X, y, test_size, random_state=3):
    <span class="org-variable-name">X_train</span>, <span class="org-variable-name">X_test</span>, <span class="org-variable-name">y_train</span>, <span class="org-variable-name">y_test</span> = train_test_split(X, y, test_size, random_state)
    <span class="org-variable-name">datasets</span> = []
    <span class="org-keyword">for</span> dataset <span class="org-keyword">in</span> [X_train, X_test, y_train, y_test]:
        datasets.append(torch.tensor(dataset.to_numpy(), dtype=torch.float32))
    <span class="org-keyword">return</span> datasets
</pre>
</div>

</details>

<details>

<summary>
<i>Train network to predict lineup success</i>
</summary>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter">### </span><span class="org-comment">Load data</span>
<span class="org-variable-name">df5</span> = pd.read_csv(<span class="org-string">'../datasets/master_5man_lineup_clustes_2000_2020.csv'</span>, index_col=0)
<span class="org-variable-name">cluster_bpm_cols</span> = [f<span class="org-string">'cluster_{n}_bpm'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(12)]
<span class="org-variable-name">cluster_nonbpm_cols</span> = [f<span class="org-string">'cluster_{n}'</span> <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(12)]

<span class="org-variable-name">X5</span> = df5[cluster_cols]
<span class="org-variable-name">y5</span> = df5[<span class="org-string">'diff_pts'</span>]
<span class="org-variable-name">X_bpm5</span> = df5[bpm_cluster_cols]
<span class="org-variable-name">y_bpm5</span> = df5[<span class="org-string">'diff_pts'</span>]

<span class="org-comment-delimiter">### </span><span class="org-comment">Setup network, learning rate, inputs, labels,  etc.</span>
<span class="org-variable-name">input_dim</span> = [12]
<span class="org-variable-name">hidden_sizes</span> = [24, 24]
<span class="org-variable-name">output_dim</span> = [1]
<span class="org-variable-name">sizes</span> = input_dim + hidden_sizes + output_dim
<span class="org-variable-name">activation</span> = nn.ReLU
<span class="org-variable-name">mlp</span> = build_MLP(sizes, activation)
<span class="org-variable-name">mlp_learning_rate</span> = 0.0001
<span class="org-variable-name">loss_fn</span> = nn.MSELoss()
<span class="org-variable-name">optimizer</span> = torch.optim.Adam(params=mlp.parameters(), lr=mlp_learning_rate)
<span class="org-variable-name">epochs</span> = 5000
<span class="org-variable-name">test_interval</span> = 50
<span class="org-variable-name">X_train_tensor</span>, <span class="org-variable-name">X_test_tensor</span>, <span class="org-variable-name">y_train_tensor</span>, <span class="org-variable-name">y_test_tensor</span> = torch_train_test_split(X5, y5, 0.2, seed)
<span class="org-variable-name">training_losses</span>, <span class="org-variable-name">test_losses</span>, <span class="org-variable-name">test_epochs</span> = [], [], []

<span class="org-comment-delimiter">### </span><span class="org-comment">Training loop</span>
<span class="org-keyword">for</span> epoch <span class="org-keyword">in</span> <span class="org-builtin">range</span>(epochs):
    optimizer.zero_grad()
    <span class="org-variable-name">y_hat</span> = mlp(X_train_tensor)
    <span class="org-variable-name">train_loss</span> = loss_fn(y_hat.reshape(-1), y_train_tensor)
    training_losses.append(train_loss.item())
    train_loss.backward()
    optimizer.step()

    <span class="org-comment-delimiter">### </span><span class="org-comment">Evaluate on test set</span>
    <span class="org-keyword">if</span> epoch % test_interval == 0:
        test_epochs.append(epoch)
        <span class="org-keyword">with</span> torch.no_grad():
            <span class="org-variable-name">y_hat_test</span> = mlp(X_test_tensor)
            <span class="org-variable-name">test_loss</span> = loss_fn(y_hat_test.reshape(-1), y_test_tensor)
            test_losses.append(test_loss.item())

<span class="org-comment-delimiter">### </span><span class="org-comment">Plot training results:</span>
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots()
<span class="org-variable-name">train_plot</span> = sns.lineplot(x=[i <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(epochs)], y=training_losses, label=<span class="org-string">'Training Loss'</span>, ax=ax)
<span class="org-variable-name">test_plot</span> = sns.lineplot(x=test_epochs, y=test_losses, label=<span class="org-string">'Test Loss'</span>, ax=ax)
ax.set_title(<span class="org-string">'Loss by epoch: 5-player, non-bpm, 2 hidden layers'</span>, fontsize=15)
ax.set_ylabel(<span class="org-string">'MSE Loss'</span>)
ax.set_xlabel(<span class="org-string">'Epoch'</span>)
plt.tight_layout()
plt.legend();
</pre>
</div>

</details>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">players</th>
<th scope="col" class="org-left">count</th>
<th scope="col" class="org-right">mean point-diff</th>
<th scope="col" class="org-right">std point-diff</th>
<th scope="col" class="org-left">non-bpm MSE (\(\sqrt{}\))</th>
<th scope="col" class="org-left">bpm MSE (\(\sqrt{}\))</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">5</td>
<td class="org-left">1,682</td>
<td class="org-right">3.352</td>
<td class="org-right">9.439</td>
<td class="org-left">79.959 (8.94)</td>
<td class="org-left">57.851 (7.61)</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">5,222</td>
<td class="org-right">3.104</td>
<td class="org-right">7.701</td>
<td class="org-left">53.479 (7.31)</td>
<td class="org-left">31.729 (5.63)</td>
</tr>
</tbody>
</table>


<div class="figure">
<p><img src="../../assets/nba-clustering/training_plots/5player_nonbpm_2hidden.jpg" alt="5player_nonbpm_2hidden.jpg" width="48%;" style="float:left;" />
</p>
</div>

<div class="figure">
<p><img src="../../assets/nba-clustering/training_plots/5player_bpm_2hidden.jpg" alt="5player_bpm_2hidden.jpg" width="48%;" style="float:right;" />
</p>
</div>

<div class="figure">
<p><img src="../../assets/nba-clustering/training_plots/4player_nonbpm_2hidden.jpg" alt="4player_nonbpm_2hidden.jpg" width="48%;" style="float:left;" />
</p>
</div>

<div class="figure">
<p><img src="../../assets/nba-clustering/training_plots/4player_bpm_2hidden.jpg" alt="4player_bpm_2hidden.jpg" width="48%;" style="float:right;" />
</p>
</div>
<div class="clear"></div>

<p>
For fun we can try bigger networks and watch the network quickly overfit and memorize the training set:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">input_dim</span> = [12]
<span class="org-variable-name">hidden_sizes</span> = [24, 256, 512, 512, 512, 256, 24]
<span class="org-variable-name">output_dim</span> = [1]
</pre>
</div>


<div class="figure">
<p><img src="../../assets/nba-clustering/training_plots/4player_bpm_deepnet.jpg" alt="4player_bpm_deepnet.jpg" width="75%;" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0c1453d" class="outline-2">
<h2 id="6.-Wrapping-Up">6. Wrapping Up</h2>
<div class="outline-text-2" id="text-6.-Wrapping-Up">
<p>
The initial motivation for this project was to improve the current taxonomy of player types in NBA conversations. The clustering results do provide much more context than the 5 traditional positions, but they are far from an ideal positional hierarchy. To improve on my approach in the future, I would find a more robust way to separate out playing style from effectiveness. Having distinct axes of style and effectiveness would allow for a cleaner comparison between players of similar roles, as well as between the relative value of different styles with respect to team and lineup success. I think predicting lineup success with accuracy within a couple of points is difficult and I would pursue a regression based on the lineup's player stats from recent seasons, league stats from recent seasons, and historical league trends, as opposed to a regression based solely on player type; there is too much variation across individual players to rely on labels like the cluster profiles I used.
</p>

<p>
The next NBA project I work on will probably revolve around NBA player-tracking data. There are many cool possibilities; estimating possession outcomes in real-time, isolating patterns of good and bad possessions, player/coach/league evolution across several seasons. We'll see!
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://twitter.com/harrisonmc15/status/909634206355066880">Kevin Durant</a> exposes his burner habit in 2017 and <a href="https://twitter.com/BarstoolBigCat/status/1298268797741043713">defends</a> it in 2020.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://youtu.be/CRYGTI9FPmI?t=295"><i>Game of Zones</i></a> roasts Bryan Colangelo for his <a href="https://www.theringer.com/nba/2018/5/29/17406750/bryan-colangelo-philadelphia-76ers-twitter-joel-embiid-anonymous-markelle-fultz">horde of twitter burners</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
The bottom 14 teams in each NBA season enter into a lottery for draft position. Lower ranking teams have increased odds of better draft positions. In the current system the bottom three teams each have a 14% of receiving the 1st overall selection. The structure of the lottery is the source of much discussion (re: tanking) as it figures prominently in the destiny of teams, especially given how star dependent success in the NBA is.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
Compare <a href="https://www.statmuse.com/nba/ask?q=jayson+tatum+shot+chart+2018-19+season">this</a> Jayson Tatum chart from 2018-19 to <a href="https://www.statmuse.com/nba/ask?q=jayson+tatum+shot+chart+2019-20+season">this</a> much prettier one from 2019-20.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
On <a href="https://www.basketball-reference.com/players/i/iversal01.html">basketball reference</a> a player id is built with the first 5 characters of the players last name, first two characters of the first name, and two numbers to differentiate duplicate name codes. For example, Allen Iverson's player id is <code>"iversal01"</code> and Wesley Mathews is <code>"matthwe02"</code> given that his father, Wes Mathews, already occupies the <code>"matthwe01"</code> id.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
This tool was convenient for gathering biographical data but was not capable of providing accurate season statistics in the categories I was looking for. Here is the <a href="https://sportsreference.readthedocs.io/en/stable/">documentation</a>. It is also slow fetching data, but I can imagine using it again for different tasks.
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
86.84% of player-seasons have a maximum cluster probability greater than or equal to 90%.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
The NBA has a soft <a href="https://en.wikipedia.org/wiki/NBA_salary_cap">salary cap</a> that limits the amount that teams can spend each year. Teams that spend beyond the salary cap must pay"luxury tax" payments that escalate quickly as well as suffer restricted access to free agent players who are in the market for new contracts. Managing current and future "cap space" is a primary focus of NBA front offices. The cap and related rules are outlined in the collective bargaining agreement.
</p></div></div>


</div>
</div>
